#!/usr/bin/env bash

# ==========================================
#     .functions
#
#  - jdk
#  - manpdf
#  - mkd = mkdir + cd
#  - cdf = cd + finder
#  - targz = -> .tar.gz
#  - extract
#  - fs = du [with options]
#  - json
#  - tre
# ==========================================


# Docker images start/stop
# Usage start_docker_image $name $volume_dir $image $port[]
# function start_docker_image() {
#   name=$1
#   volume_dir=$2
#   image=$3
#   args=("$@")
#   args_num=${#args[@]}
#   if [ "$(docker ps -q -f name=$name)" ]; then
#     docker rm -f $name
#   else
#     docker run -d for ((i=2;i<$args_num;i++)); do echo -p ${args[${i}]} done -v $HOME/.docker/$name:$volume_dir --name $name $image
#   fi
# }

# Set Java JDK version (https://github.com/AdoptOpenJDK/homebrew-openjdk)
function jdk() {
  local version=$1

  if [[ $version == "graal" ]]
  then
    version=$(/usr/libexec/java_home -V 2>&1 | grep -Eo '([0-9\.]+),.+graalvm-..-java[0-9\.-]+-' | awk '{gsub(/,/,""); print $1}')
  fi

  export JAVA_HOME=$(/usr/libexec/java_home -v"$version")
  java -version
}

# Update sbt version to latest in current project
function sbt-latest() {
  local latestsbt=$(curl -s https://repo1.maven.org/maven2/org/scala-sbt/sbt/maven-metadata.xml | xmllint --xpath '/metadata/versioning/latest/text()' -)
  # local latestscala=$(curl -s https://repo1.maven.org/maven2/org/scala-lang/scala-compiler/maven-metadata.xml | xmllint --xpath '/metadata/versioning/latest/text()' -)

  echo "sbt.version = $latestsbt" > project/build.properties
}

# Open man page as PDF
function manpdf() {
  man -t "${1}" | open -f -a /Applications/Preview.app/
}

# Create a new directory and enter it
function mkd() {
  mkdir -p "$@" && cd "$_";
}

# Open file in $EDITOR
function editf() {
  $EDITOR $1
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
  cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')";
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
  local tmpFile="${@%/}.tar";
  tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

  size=$(
    stat -f"%z" "${tmpFile}" 2> /dev/null; # macOS `stat`
    stat -c"%s" "${tmpFile}" 2> /dev/null;  # GNU `stat`
  );

  local cmd="";
  if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
    # the .tar file is smaller than 50 MB and Zopfli is available; use it
    cmd="zopfli";
  else
    if hash pigz 2> /dev/null; then
      cmd="pigz";
    else
      cmd="gzip";
    fi;
  fi;

  echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`â€¦";
  "${cmd}" -v "${tmpFile}" || return 1;
  [ -f "${tmpFile}" ] && rm "${tmpFile}";

  zippedSize=$(
    stat -f"%z" "${tmpFile}.gz" 2> /dev/null; # macOS `stat`
    stat -c"%s" "${tmpFile}.gz" 2> /dev/null; # GNU `stat`
  );

  echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully.";
}

# Determine size of a file or total size of a directory
function fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh;
  else
    local arg=-sh;
  fi
  if [[ -n "$@" ]]; then
    du $arg -- "$@";
  else
    du $arg .[^.]* ./*;
  fi;
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
  tree -aC -I '.git|.Trash|.DS_Store|.idea|.ipynb_checkpoints|.RData|.Rhistory' --dirsfirst "$@" | less -FRNX;
}
