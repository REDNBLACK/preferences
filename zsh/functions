# ====================================================================================== #
#                                 functions                                              #
# ====================================================================================== #
# - show                   = formatted print                                             #
# - mkd                    = mkdir + cd or mkdir only if dir not exists                  #
# - vpn                    = connect to Cisco AnyConnect or OpenConnect VPN              #
# - dns                    = reload dns, make domain alias for localhost with port       #
# - osx-env                = manipulate macOS launchctl env                              #
# - upgrade                = update manager                                              #
# - internal               = internal tools                                              #
# - targz                  = -> .tar.gz                                                  #
# - fs                     = du [with options]                                           #
# ====================================================================================== #

# Print formatted info/error/debug
function show() {
  zparseopts -D -E -F - l::=label r=rainbow e=error d=debug h=help -help=help

  local usage=$(cat <<EOF
${fg_bold[blue]}Usage:${reset_color} show [options…] <text> ${fg[cyan]}Pretty printing and show${reset_color}

${fg_bold[blue]}Options:${reset_color}
  ${fg_bold[yellow]}-r${reset_color}                 ${fg[blue]}Show message text with rainbow color${reset_color}
  ${fg_bold[yellow]}-e${reset_color}                 ${fg[blue]}Set message level to Error${reset_color}
  ${fg_bold[yellow]}-d${reset_color}                 ${fg[blue]}Set message level to Debug${reset_color}
  ${fg_bold[yellow]}-l <label>${reset_color}         ${fg[blue]}Prepend label before message (always shown after message level, if set)${reset_color}
  ${fg_bold[yellow]}--help${reset_color}             ${fg[blue]}Show help (this message) and exit${reset_color}

${fg_bold[blue]}Examples:${reset_color}
  show "Hello there" ${fg_bold[yellow]}-l${reset_color} "Me" ${fg[blue]}Show info message with label${reset_color} ${fg_bold[yellow]}Me${reset_color}
  show ${fg_bold[yellow]}-e${reset_color} "Oh god, failure"  ${fg[blue]}Show error message${reset_color}
  show ${fg_bold[yellow]}-d${reset_color} "Debugging" "Here" ${fg[blue]}Show debug message${reset_color}
EOF
)
  local label=$([ ! -z "$label" ] && echo "[${label#-l}]" || echo '')

  if [[ ${#help} = 1 ]]; then
    echo $usage
  elif [[ ${#error} = 1 ]]; then
    echo -e $fg_bold[red]"[Error]"${label}" $@"$reset_color
  elif [[ ${#debug} = 1 ]]; then
    echo -e $fg_bold[yellow]"[Debug]"${label}${EOL}"$@"$reset_color
  else
    [[ ! -z $label ]] && label+=' '
    if [[ ${#rainbow} = 1 ]]; then
      echo -e "$(echo -n ${label}"$@" | lolcat -f)"
    else
      echo -e $fg_bold[blue]${label}"$@"$reset_color
    fi
  fi
}

# Docker images start/stop
# Usage start_docker_image $name $volume_dir $image $port[]
# function start_docker_image() {
#   name=$1
#   volume_dir=$2
#   image=$3
#   args=("$@")
#   args_num=${#args[@]}
#   if [ "$(docker ps -q -f name=$name)" ]; then
#     docker rm -f $name
#   else
#     docker run -d for ((i=2;i<$args_num;i++)); do echo -p ${args[${i}]} done -v $HOME/.docker/$name:$volume_dir --name $name $image
#   fi
# }

# Advanced `mkdir`
function mkd() {
  zparseopts -D -E -F - e=exists s=silent h=help -help=help

  local usage=$(cat <<EOF
${fg_bold[blue]}Usage:${reset_color} mkd [options…] <path to dir> ${fg[cyan]}Advanced mkdir${reset_color}

${fg_bold[blue]}Options:${reset_color}
  ${fg_bold[yellow]}-e${reset_color}                 ${fg[blue]}Create directory only if not exists (disables cd inside)${reset_color}
  ${fg_bold[yellow]}-s${reset_color}                 ${fg[blue]}Do not print message when creating directory with ${fg_bold[yellow]}-e${reset_color} ${fg[blue]}flag${reset_color}
  ${fg_bold[yellow]}--help${reset_color}             ${fg[blue]}Show help (this message) and exit${reset_color}

${fg_bold[blue]}Examples:${reset_color}
  mkd ${fg_bold[yellow]}-e${reset_color} a/new/dir     ${fg[blue]}Create dir if not exists, showing message on launch${reset_color}
  mkd ${fg_bold[yellow]}-e${reset_color} ${fg_bold[yellow]}-s${reset_color} a/new/dir  ${fg[blue]}Create dir if not exists, silently${reset_color}
  mkd a/new/dir        ${fg[blue]}Create dir and then cd inside of it${reset_color}
EOF
)

  if [[ ${#help} = 1 ]]; then
    echo $usage
  elif [[ $# -lt 1 ]]; then
    show -e "Path to dir not passed!"
  else
    if [[ ${#exists} = 1 ]]; then
      if [[ ! -e "$@" ]]; then
        [[ ${#silent} = 1 ]] || show "Creating directory $@..."
        mkdir -p "$@"
      fi
    else
      mkdir -p "$@" && cd "$_"
    fi
  fi
}

# Manage connection to Cisco AnyConnect VPN
function vpn() {
  zparseopts -D -E -F - kc::=keychain -keychain::=keychain s=secure -secure=secure a=auto -auto=auto h=help -help=help

  declare -A opts=(
    [pkg]='com.cisco.anyconnect'
    [bin]='/opt/cisco/anyconnect/bin'
    [apps]='/Applications/Cisco'
    [agents]='/Library/LaunchAgents'
    [daemons]='/Library/LaunchDaemons'
    [totp]="$1"
    [secure]=${#secure}
    [auto]=${#auto}
    [keychain]=${${keychain#(--keychain|-kc)}:-"CiscoVPN"}
  )
  declare -A procx=(
    [agent]="${opts[daemons]}/${opts[pkg]}.vpnagentd.plist"
    [ise]="${opts[agents]}/${opts[pkg]}.aciseposture.plist"
    [notify]="${opts[agents]}/${opts[pkg]}.notification.plist"
    [gui]="${opts[agents]}/${opts[pkg]}.gui.plist"
    [cli]="${opts[bin]}/vpn"
    [app]='Cisco AnyConnect Secure Mobility Client.app'
    [ext]="${opts[pkg]}.macos.acsockext"
  )

  local usage=$(cat <<EOF
${fg_bold[blue]}Usage:${reset_color} vpn [options…] <TOTP> ${fg[cyan]}Manage connection to Cisco AnyConnect based VPN${reset_color}

${fg_bold[blue]}Options:${reset_color}
  ${fg_bold[yellow]}--secure${reset_color}           ${fg[blue]}Connect to VPN using native Cisco AnyConnect client${reset_color} ${fg[cyan]}(without flag OpenConnect client will be used)${reset_color}
  ${fg_bold[yellow]}--keychain${reset_color} <entry> ${fg[blue]}Name of KeyChain entry to use for connection${reset_color} ${fg[cyan]}(CiscoVPN entry will be used if not set)${reset_color}
  ${fg_bold[yellow]}--auto${reset_color}             ${fg[blue]}Automatically retrieve TOTP for VPN${reset_color} ${fg[cyan]}(Requires installed macos-totp-cli)${reset_color}
  ${fg_bold[yellow]}--help${reset_color}             ${fg[blue]}Show help (this message) and exit${reset_color}

${fg_bold[blue]}Setup:${reset_color}
  ${fg[blue]}Store your VPN connection credentials to secure macOS KeyChain by executing${reset_color} ${fg[cyan]}(required step in order for this program to work):${reset_color}
      security add-internet-password ${fg_bold[yellow]}-l${reset_color} CiscoVPN ${fg_bold[yellow]}-r${reset_color} htps ${fg_bold[yellow]}-s${reset_color} %HOST% ${fg_bold[yellow]}-a${reset_color} %GROUP%/%USER% ${fg_bold[yellow]}-w${reset_color} %PASSWORD%
  ${fg[blue]}Store your VPN connection TOTP secret to secure macOS KeyChain by executing${reset_color} ${fg[cyan]}(OPTIONALLY, if macos-totp-cli installed):${reset_color}
      totp add CiscoVPN
      %TOTP Secret%
  ${fg[blue]}Install manually if you want to use native client:${reset_color}
      cisco-any-connect.pkg
  ${fg[blue]}...or execute this if you prefer openconnect$reset_color ${fg[cyan]}(depends on gmp bdw-gc libffi libtool libunistring pkg-config guile libidn2 libtasn1 nettle p11-kit libevent unbound gnutls stoken):${reset_color}
      brew install openconnect

${fg_bold[blue]}Examples:${reset_color}
  vpn ${fg_bold[yellow]}--keychain${reset_color} SuperVPN ${fg_bold[yellow]}--secure${reset_color} 133742   ${fg[blue]}Connect via native client using 'SuperVPN' KeyChain entry${reset_color}
  vpn 800855                                ${fg[blue]}Connect via openconnect using default KeyChain entry 'CiscoVPN'${reset_color}
  vpn                                       ${fg[blue]}Disconnect and gracefully close all Cisco VPN daemons and workers${reset_color}
EOF
)

  if [ ${#help} = 1 ]; then
    echo $usage
  else
    local type=$([ ${opts[secure]} = 0 ] && echo 'OpenConnect' || echo 'Cisco AnyConnect')
    # local uid=`echo "show State:/Users/ConsoleUser" | scutil | awk '/UID/ { print $3 }'`
    local stopped=$(([ -z `pgrep vpnagentd` ] && [ -z `pgrep aciseposture` ] && [ -z `pgrep openconnect` ]) && echo 1 || echo 0)

    # show -d "    '$keychain' '$secure' '$type' '$stopped'$EOL    '$totp'"

    assert() {
       "$@" 2>&1 | {
         read -d "\0" err
         [ -z "$err" ] || show -e -l 'VPN' $err
      }
      unset err
    }

    loop() {
      declare -i sec=$1; shift
      local msg="$2";    shift

      while [ -n "`$@`" ];
      do ((sec--)); sleep 1;
        show -l 'Loop' "$sec"
        if [ $sec -eq 0 ]; then show -e -l 'VPN' $msg; break; fi
      done
    }

    start() {
      local raw=$(security 2>&1 find-internet-password -gl ${opts[keychain]} | tr $EOL ' ')
      local host=$(sed -nE 's:.*"srvr"<blob>="([^"]*)".*:\1:p' <<< $raw)
      local acc=(${(Oas:/:)$(sed -nE 's:.*"acct"<blob>="([^"]*)".*:\1:p' <<< $raw)})
      local pass=$(sed -nE 's:.*password\: "([^"]*)".*:\1:p' <<< $raw)
      local totp=$([ ${opts[auto]} = 1 ] && totp get ${opts[keychain]} || echo ${opts[totp]})

      # show -d "    '$host'$EOL    [${#acc[@]}]: '$acc'$EOL    '$pass'"

      if [ ${opts[secure]} = 0 ]; then
        ## OpenConnect
        local args=(
          '--background'
          "--user=${acc[1]}"
          '--passwd-on-stdin'
        )
        if [ ! -z "${acc[2]}" ]; then args+=("--authgroup=${acc[2]}"); fi

        printf '%s\n' $pass $totp | sudo openconnect $args $host
      else
        # Cisco AnyConnect
        local auth=()
        if [ ! -z "${acc[2]}" ]; then
          ## Group always "0" for Cisco native client
          auth+=("0" "${acc[1]}")
        else
          auth+=("${acc[1]}")
        fi

        assert sudo launchctl bootstrap system ${procx[agent]}
        printf '%s\n' $auth $pass $totp | ${procx[cli]} -s connect $host
        assert sudo launchctl bootstrap system ${procx[ise]}
      fi
    }

    stop() {
      # OpenConnect
      sudo pkill -2 'openconnect' 2>&1

      # Cisco AnyConnect
      ## Kill GUI & CLI
      sudo launchctl bootout system ${procx[gui]} ${procx[notify]} > /dev/null 2>&1
      sudo pkill -2 -f ${procx[app]} ${procx[cli]} 2>&1
      sudo rm -f ${procx[gui]} ${procx[notify]} 2>&1
      loop 5 'Timeout waiting for GUI to stop' pgrep -f ${procx[app]}

      ## Kill Daemons
      sudo launchctl bootout system ${procx[agent]} ${procx[ise]} > /dev/null 2>&1
      loop 10 'Timeout waiting for Daemons to stop' pgrep -f "${opts[bin]}/vpnagentd"

      ## Disable and Remove System Extensions
      sudo pkill -9 -f ${opts[bin]} 2>&1
      if [ -n "$(systemextensionsctl list | grep ${procx[ext]} | uniq)" ]; then
        declare -A mode=([lock]='authenticate-admin-nonshared' [allow]='allow')
        local before=$(/usr/libexec/PlistBuddy -c "Print rule:0" /dev/stdin <<< "$(security authorizationdb read com.apple.system-extensions.admin 2>&1)")

        # Temporary allow system extensions to be uninstalled without password prompt
        if [ $before = "${mode[lock]}" ]; then
          security authorizationdb write com.apple.system-extensions.admin "${mode[allow]}" > /dev/null 2>&1 \
            || show -e -l 'VPN' "Failed to update SecurityDB with allow mode, code $?"
        fi

        # Deactivate and remove Cisco System Extensions
        sudo "/Applications/Cisco/Cisco AnyConnect Socket Filter.app/Contents/MacOS/Cisco AnyConnect Socket Filter" -deactivateExt
        # sudo systemextensionsctl uninstall DE8Y96K9QP ${procx[ext]}

        # Revert back system extensions security
        security authorizationdb write com.apple.system-extensions.admin "$before" > /dev/null 2>&1 \
          || show -e -l 'VPN' "Failed to revert SecurityDB with $before mode, code $?"
      fi
    }

    if [ $stopped = 1 ] && [ ${opts[auto]} = 0 ] && [ "${opts[totp]}" = '' ]; then
      show -e -l 'VPN' 'TOTP is empty!'
    elif [ $stopped = 1 ] && [[ ${opts[auto]} = 1 || -n "${opts[totp]}" ]]; then
      show -l 'VPN' "Launching $type..."
      start
    elif [ $stopped = 0 ] && [ ${opts[auto]} = 0 ] && [ "${opts[totp]}" = '' ]; then
      show -l 'VPN' 'Closing...'
      stop
    elif [ $stopped = 0 ] && [[ ${opts[auto]} = 1 || -n "${opts[totp]}" ]]; then
      show -l 'VPN' "Restarting $type..."
      stop
      start
    fi
  fi
}

# Manage DNS
function dns() {
  local usage="Try me"
  declare -A file=(
    [firewall]='/etc/pf.conf'
    [hosts]='/etc/hosts'
    [redirect]='/etc/pf.anchors/domain.alias'
  )

  inject() {
    local opts=($2 $3)
    if [ "$1" = 'delete' ]; then; opts[2]=(); fi
    sudo sed -i '' -n ${opts[@]/#/-e } $4
  }

  case $1 in
    (reload)   # Reset DNS Cache
      sudo killall -HUP mDNSResponder
    ;;
    (firewall) # Manipulate Firewall settings
      local mode="$2"

      output=("${(@f)$(sudo pfctl -q $mode -f ${file[firewall]} 2>&1)}")
      printf '%s\n' ${output[@]:3} && if [ $mode = '-d' ]; then; sleep 3; fi
    ;;
    (alias)    # Alias localhost with port to domain
      # /System/Library/LaunchDaemons/com.apple.pfctl.plist - <string>-e</string>
      declare -A addr=([base]='127.0.0.' [domain]="$2" [port]="$3")
      addr[all]="$(sed -nE 's#^'${addr[base]}'([0-9]+)[[:space:]]+(.+)$#\2=\1#p' ${file[hosts]})"
      addr[local]="${addr[base]}${$([[ "${addr[all]}" =~ ${addr[domain]}=([0-9]+) ]] && echo "${match[1]}" || echo "$(echo ${addr[all]} | cut -d'=' -f2 | sort -n | tail -1 | awk '{print $1 + 1}')")}"

      declare -A cmd=(
        [expr]="rdr pass on lo0 inet proto tcp from any to ${addr[local]} port 80 -> ${addr[base]}1 port ${addr[port]}"
        [anchor]='rdr-anchor "domain.alias"'
        [load]='load anchor "domain.alias" from'
      )

      show -d "${addr[all]}\n${addr[local]}"

      ## Create or update redirect
      [ ! -e $file[redirect] ] && sudo tee $file[redirect] <<< "# Domain Redirect Aliases ruleset" > /dev/null
      inject 'both' '/^.*'${addr[local]}' port 80.*$/!p' '$a\'$'\n'${cmd[expr]} ${file[redirect]}

      ## Configure and load redirect
      inject 'both' '/^'${cmd[anchor]}'$/!p' '/rdr-anchor "com.apple\/\*"/a\'$'\n'${cmd[anchor]} ${file[firewall]}
      inject 'both' '/^'${cmd[load]}' "'$(sed 's:/:\\/:g' <<< ${file[redirect]})'"/!p' '$a\'$'\n'${cmd[load]}' "'${file[redirect]}'"' ${file[firewall]}
      dns firewall -n && dns firewall -d && dns firewall -e

      ## Create or update domain -> ip mapping in hosts and reload DNS
      inject 'both' '/^'${addr[base]}'[0-9]* '${addr[domain]}'/!p' '$a\'$'\n'${addr[local]}' '${addr[domain]} ${file[hosts]}
      dns reload

      show -l 'DNS' "Start apps at ${addr[local]}:${addr[port]} and view them at http://${addr[domain]}/"
    ;;
    (-h | --help) echo $usage ;;
    (*)           show -e 'Wrong arguments, see --help'
  esac
}

# Update/upgrade homebrew, homebrew cask, MAS and system
function upgrade() {
  show '[Brew Formula]'
  brew update | lolcat
  brew upgrade --display-times --formula 2>&1 | lolcat
  brew cleanup formula -s --prune 1 2>&1 | lolcat

  show $EOL'[Brew Cask]'
  brew cu -a -y --no-brew-update --no-quarantine --cleanup 2>&1 | lolcat

  if (( $+commands[mas] )); then
    show $EOL'[AppStore]'
    mas upgrade 2>&1 | lolcat
  fi

  show $EOL'[System]'
  softwareupdate -ia 2>&1 | lolcat

  show $EOL'[ZInit]'
  zinit self-update 2>&1 | lolcat
  zinit update -q --plugins 2>&1 | lolcat

  if (( $+commands[tldr] )); then
    show $EOL$EOL'[TLDR]'
    tldr -u 2>&1 | lolcat
  fi
}

function internal() {
  local usage=$(cat <<EOF
${fg_bold[blue]}Usage:${reset_color} internal <command> ${fg[cyan]}Execute internal helper function${reset_color}

${fg_bold[blue]}Commands:${reset_color}
  ${fg_bold[yellow]}app-installed <app-name>${reset_color}      ${fg[blue]}Check if macOS app installed in Applications folder${reset_color}
  ${fg_bold[yellow]}set-file-assoc <app-name> <handler> <path to file w/ assoc>${reset_color}      ${fg[blue]}Set files association for app${reset_color}
  ${fg_bold[yellow]}download <uri> <save path> <app-name>${reset_color}      ${fg[blue]}Download and save file to directory${reset_color}

${fg_bold[blue]}Examples:${reset_color}
  internal --init  ${fg[blue]}Do something${reset_color}
EOF
)

  case $1 in
    (app-installed)  # Check if Mac App installed
      local app=$2

      if [[ ! -d ~/Applications/"$app".app && ! -d /Applications/"$app".app ]]; then
        return 1
      fi
      return 0
    ;;
    (set-file-assoc) # Set files association
      local label=$2
      local handler=$3
      local file=$4

      if [[ ! -r "$file"  ]]; then
        show -e "Can't read file $file"
      elif (( !$+commands[duti] )); then
        show -e 'duti required to set files association'
      else
        show -l $label 'Setting file associations...'
        cat "$file" | awk -v "handler=$handler" '{print handler, $1, "all"}' | duti -v
      fi
    ;;
    (download)       # Download and save file
      local uri=$2
      local dest=$3
      local label=$4

      show -l $label "Downloading $(basename $dest | cut -d. -f1)..."
      curl -sSL $uri -o $dest --create-dirs
    ;;
    (-h | --help) echo $usage ;;
    (*)           show -e 'Wrong arguments, see --help'
  esac
}

function osx-env() {
  local usage=$(cat <<EOF
${fg_bold[blue]}Usage:${reset_color} osx-env <command> ${fg[cyan]}${reset_color}

${fg_bold[blue]}Commands:${reset_color}
  ${fg_bold[yellow]}install${reset_color}      ${fg[blue]}Do them${reset_color}
  ${fg_bold[yellow]}uninstall${reset_color}      ${fg[blue]}Do it${reset_color}
  ${fg_bold[yellow]}sync${reset_color}      ${fg[blue]}Do shit${reset_color}

${fg_bold[blue]}Examples:${reset_color}
  osx-env sync
EOF
)

  declare -A opts=(
    [label]='OSXEnvSync'
    [sep]='±'
    [profile]="$ZDOTDIR/profile"
    [agent]=~/Library/LaunchAgents/osx-env.sync.plist
    [load]="$OSXENVDIR/load.sh"
    [unload]="$OSXENVDIR/unload.sh"
  )

  make() {
    mkd -e -s $OSXENVDIR

    sed -E -n 's/^declare -gx ([^ =]+)=(.+) +# +SYS +#$/\1'${opts[sep]}'\2/p' ${opts[profile]} | while IFS=${opts[sep]} read -r k v
    do
      show -l $opts[label] "[$k] -> ($v)"
      tee -a ${opts[load]}   <<< "launchctl setenv $k $v" > /dev/null
      tee -a ${opts[unload]} <<< "launchctl unsetenv $k"  > /dev/null
    done
    chmod +x ${opts[load]} ${opts[unload]}

    cat > ${opts[agent]} <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key>
  <string>osx-env.sync</string>
  <key>ProgramArguments</key>
  <array>
    <string>bash</string>
    <string>-l</string>
    <string>-c</string>
    <string>${opts[load]}</string>
  </array>
  <key>RunAtLoad</key>
  <true/>
</dict>
</plist>
EOF
    launchctl load ${opts[agent]}
  }

  destroy() {
    launchctl unload ${opts[agent]} > /dev/null 2>&1
    rm -f ${opts[agent]} ${opts[load]} ${opts[unload]}
  }

  case $1 in
    (install)  # Generate script and load to LaunchAgents
      if [[ -f ${opts[agent]} ]]; then
        show -l $opts[label] -e 'LaunchAgent already installed and running, run uninstall before proceeding'
      elif [[ -f ${opts[load]} || -f ${opts[unload]} ]]; then
        show -l $opts[label] -e 'Sync script corrupted, run uninstall before proceeding'
      else
        make
        show -l $opts[label] 'Sucessfully Loaded'
      fi
    ;;
    (uninstall) # Unload script from LaunchAgents and remove all generated files
      destroy
      show -l $opts[label] 'Sucessfully Uninstalled'
    ;;
    (sync)      # Regenerate file and restart agent
      destroy
      make
      show -l $opts[label] 'Sucessfully Synced'
    ;;
    (-h | --help) echo $usage ;;
    (*)           show -e 'Wrong arguments, see --help'
  esac
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
  local tmpFile="${@%/}.tar"
  tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1

  size=$(
    stat -f"%z" "${tmpFile}" 2> /dev/null; # macOS `stat`
    stat -c"%s" "${tmpFile}" 2> /dev/null;  # GNU `stat`
  )

  local cmd="";
  if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
    # the .tar file is smaller than 50 MB and Zopfli is available; use it
    cmd="zopfli"
  else
    if hash pigz 2> /dev/null; then
      cmd="pigz"
    else
      cmd="gzip"
    fi
  fi

  show "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`…"

  "${cmd}" -v "${tmpFile}" || return 1;
  [ -f "${tmpFile}" ] && rm "${tmpFile}";

  zippedSize=$(
    stat -f"%z" "${tmpFile}.gz" 2> /dev/null; # macOS `stat`
    stat -c"%s" "${tmpFile}.gz" 2> /dev/null; # GNU `stat`
  )

  show "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully"
}

# Determine size of a file or total size of a directory
function fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local cmd=-sbh;
  else
    local cmd=-sh;
  fi
  if [[ -n "$@" ]]; then
    du $cmd -- "$@";
  else
    du $cmd .[^.]* ./*;
  fi
}
